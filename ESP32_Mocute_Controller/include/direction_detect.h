/**
 * @file direction_detect.h
 * @brief Richtungserkennung aus Dual-RSSI (Master + Satellite)
 *
 * Verwendet die RSSI-Differenz zwischen zwei ESP32-Modulen
 * (links und rechts am Hoverboard montiert), um die Richtung
 * des Benutzers relativ zum Hoverboard zu bestimmen.
 *
 * Prinzip:
 *   RSSI_Master > RSSI_Satellite → Nutzer ist näher an Master-Seite
 *   RSSI_Satellite > RSSI_Master → Nutzer ist näher an Satellite-Seite
 *   RSSI_Master ≈ RSSI_Satellite → Nutzer ist mittig (vorne oder hinten)
 *
 * Die Richtung wird als Lenkwert [-1000, 1000] ausgegeben, der direkt
 * zum Follow-Me Lenkbefehl addiert oder als eigenständiger Lenkwert
 * verwendet werden kann.
 *
 * Einschränkungen:
 *   - Keine Unterscheidung zwischen vorne und hinten möglich
 *   - RSSI-Schwankungen erfordern starke Filterung
 *   - Abstand zwischen den ESP32s beeinflusst die Genauigkeit
 *   - Am besten funktioniert es im Freien mit Sichtverbindung
 */

#ifndef DIRECTION_DETECT_H
#define DIRECTION_DETECT_H

#include <Arduino.h>
#include "espnow_protocol.h"

// ========================== Direction Configuration ==========================

// RSSI difference thresholds for direction classification
// These determine how much RSSI difference is needed to detect a direction
// IMPORTANT: Must be calibrated for your specific hoverboard width and environment!

// Minimum RSSI difference to consider a direction (deadzone)
// Below this, direction is considered CENTER
#define DIR_RSSI_DEADZONE       5     // RSSI units (BTstack 0-255 scale)

// RSSI difference for strong left/right detection
#define DIR_RSSI_STRONG         20    // Strong direction signal

// Maximum steering angle generated by direction detection
#define DIR_STEER_MAX           300   // Max auto-steering value [-1000, 1000]

// Minimum steering angle when direction is detected
#define DIR_STEER_MIN           50    // Minimum steering to actually turn

// Filter coefficient for direction (more filtering = smoother but slower)
#define DIR_FILTER_ALPHA        0.10f // EMA filter for RSSI difference

// Satellite RSSI timeout: how long before satellite data is considered stale
#define DIR_SATELLITE_TIMEOUT_MS  1500

// ========================== Direction State ==========================

enum DirectionZone : uint8_t {
    DIR_CENTER = 0,       // User is roughly centered or unknown
    DIR_LEFT,             // User is to the left
    DIR_RIGHT,            // User is to the right
    DIR_LEFT_STRONG,      // User is strongly to the left
    DIR_RIGHT_STRONG,     // User is strongly to the right
};

class DirectionDetector {
public:
    DirectionDetector() {}

    /**
     * @brief Update the master's own RSSI reading
     * @param rssi Master RSSI (BTstack 0-255, higher = closer)
     */
    void updateMasterRssi(uint8_t rssi) {
        _masterRssi = rssi;
        _hasMasterRssi = true;
        _lastMasterTime = millis();
    }

    /**
     * @brief Update the satellite's RSSI reading (received via ESP-NOW)
     * @param rssi Satellite RSSI (BTstack 0-255, higher = closer)
     * @param confidence Measurement confidence 0-100
     */
    void updateSatelliteRssi(uint8_t rssi, uint8_t confidence = 100) {
        _satelliteRssi = rssi;
        _satelliteConfidence = confidence;
        _hasSatelliteRssi = true;
        _lastSatelliteTime = millis();

        // Compute direction when both RSSI values are available
        if (_hasMasterRssi) {
            computeDirection();
        }
    }

    /**
     * @brief Get the computed steering value for direction correction
     * @return Steering value [-DIR_STEER_MAX, DIR_STEER_MAX]
     *         Negative = steer left, positive = steer right
     *         0 = no direction correction or not enough data
     *
     * Sign convention follows the Master's mounted side:
     *   If Master is RIGHT: positive diff (master stronger) → user is RIGHT → steer RIGHT (+)
     *   If Master is LEFT:  positive diff (master stronger) → user is LEFT → steer LEFT (-)
     */
    int16_t getDirectionSteer() {
        if (!isAvailable()) return 0;

        // Check for stale satellite data
        if (millis() - _lastSatelliteTime > DIR_SATELLITE_TIMEOUT_MS) {
            _zone = DIR_CENTER;
            return 0;
        }

        return _steerOutput;
    }

    /**
     * @brief Check if direction detection is available
     * @return true if both RSSI sources have recent data
     */
    bool isAvailable() const {
        if (!_hasMasterRssi || !_hasSatelliteRssi) return false;
        if (millis() - _lastSatelliteTime > DIR_SATELLITE_TIMEOUT_MS) return false;
        return true;
    }

    /**
     * @brief Check if satellite ESP32 is communicating
     */
    bool isSatelliteOnline() const {
        return _hasSatelliteRssi &&
               (millis() - _lastSatelliteTime < ESPNOW_TIMEOUT_MS);
    }

    // Getters
    DirectionZone getZone() const { return _zone; }
    float getFilteredDiff() const { return _filteredDiff; }
    uint8_t getMasterRssi() const { return _masterRssi; }
    uint8_t getSatelliteRssi() const { return _satelliteRssi; }
    uint8_t getSatelliteConfidence() const { return _satelliteConfidence; }

    const char* getZoneName() const {
        switch (_zone) {
            case DIR_CENTER:       return "CENTER";
            case DIR_LEFT:         return "LEFT";
            case DIR_RIGHT:        return "RIGHT";
            case DIR_LEFT_STRONG:  return "LEFT++";
            case DIR_RIGHT_STRONG: return "RIGHT++";
            default:               return "???";
        }
    }

    /**
     * @brief Print calibration info to Serial
     */
    void printCalibration() {
        Serial.printf("[DIR-CAL] Master RSSI=%u, Satellite RSSI=%u, "
                      "Diff=%.1f, Zone=%s, Steer=%d, Confidence=%u%%\n",
                      _masterRssi, _satelliteRssi,
                      _filteredDiff, getZoneName(),
                      _steerOutput, _satelliteConfidence);
    }

private:
    /**
     * @brief Compute direction from RSSI difference
     *
     * The RSSI difference indicates which side the user is on:
     *   diff = masterRssi - satelliteRssi
     *
     * The sign convention depends on which side the Master is mounted.
     * Default: Master = RIGHT sideboard
     *   diff > 0 → user closer to Master (right) → steer right (+)
     *   diff < 0 → user closer to Satellite (left) → steer left (-)
     */
    void computeDirection() {
        // Raw RSSI difference
        float rawDiff = (float)_masterRssi - (float)_satelliteRssi;

        // Apply side convention
        // If Master is on LEFT side, invert the sign convention
        // so positive always means "steer right" and negative means "steer left"
        #if MASTER_SIDE == SIDE_LEFT
        rawDiff = -rawDiff;
        #endif

        // Apply confidence weighting
        float confWeight = (float)_satelliteConfidence / 100.0f;
        rawDiff *= confWeight;

        // EMA filter on the difference
        if (!_filterInitialized) {
            _filteredDiff = rawDiff;
            _filterInitialized = true;
        } else {
            _filteredDiff = DIR_FILTER_ALPHA * rawDiff +
                           (1.0f - DIR_FILTER_ALPHA) * _filteredDiff;
        }

        // Classify direction zone
        float absDiff = fabs(_filteredDiff);
        if (absDiff < DIR_RSSI_DEADZONE) {
            _zone = DIR_CENTER;
            _steerOutput = 0;
        } else if (absDiff >= DIR_RSSI_STRONG) {
            // Strong direction
            _zone = (_filteredDiff > 0) ? DIR_RIGHT_STRONG : DIR_LEFT_STRONG;
            _steerOutput = (_filteredDiff > 0) ? DIR_STEER_MAX : -DIR_STEER_MAX;
        } else {
            // Proportional direction
            _zone = (_filteredDiff > 0) ? DIR_RIGHT : DIR_LEFT;

            // Map [DEADZONE, STRONG] to [STEER_MIN, STEER_MAX]
            float ratio = (absDiff - DIR_RSSI_DEADZONE) /
                          (DIR_RSSI_STRONG - DIR_RSSI_DEADZONE);
            ratio = constrain(ratio, 0.0f, 1.0f);
            int16_t steerMag = DIR_STEER_MIN + (int16_t)(ratio * (DIR_STEER_MAX - DIR_STEER_MIN));

            _steerOutput = (_filteredDiff > 0) ? steerMag : -steerMag;
        }
    }

    // State
    bool _hasMasterRssi = false;
    bool _hasSatelliteRssi = false;
    bool _filterInitialized = false;

    uint8_t _masterRssi = 0;
    uint8_t _satelliteRssi = 0;
    uint8_t _satelliteConfidence = 0;

    float _filteredDiff = 0.0f;
    int16_t _steerOutput = 0;

    DirectionZone _zone = DIR_CENTER;

    unsigned long _lastMasterTime = 0;
    unsigned long _lastSatelliteTime = 0;
};

#endif // DIRECTION_DETECT_H
